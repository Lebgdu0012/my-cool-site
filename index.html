<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plateforme de Streaming P2P</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <h1>Plateforme de Streaming P2P</h1>

  <div id="videosContainer">
    <!-- Les vidéos des utilisateurs seront ajoutées ici -->
  </div>

  <button id="startButton">Démarrer la caméra</button>

  <script>
    const startButton = document.getElementById('startButton');
    const videosContainer = document.getElementById('videosContainer');
    let localStream;
    let peerConnections = {};
    let socket;

    // Connexion WebSocket pour la signalisation entre utilisateurs
    socket = new WebSocket('ws://localhost:8080');  // Changez cette URL selon votre configuration
    
    socket.onopen = () => {
      console.log('Connecté au serveur WebSocket');
    };

    socket.onmessage = (message) => {
      const data = JSON.parse(message.data);
      
      switch (data.type) {
        case 'offer':
          handleOffer(data);
          break;
        case 'answer':
          handleAnswer(data);
          break;
        case 'ice-candidate':
          handleIceCandidate(data);
          break;
        case 'new-user':
          handleNewUser(data);
          break;
      }
    };

    // Fonction pour démarrer la caméra locale
    async function startCamera() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true });
        const myVideo = document.createElement('video');
        myVideo.srcObject = localStream;
        myVideo.autoplay = true;
        videosContainer.appendChild(myVideo);

        startButton.disabled = true;

        // Créer la connexion WebRTC pour partager la vidéo avec les autres utilisateurs
        createPeerConnection();
      } catch (error) {
        console.error('Erreur lors de l\'accès à la caméra', error);
      }
    }

    // Créer une connexion WebRTC pour chaque utilisateur
    function createPeerConnection() {
      const config = {
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      };

      // Créer un PeerConnection pour l'utilisateur local
      const peerConnection = new RTCPeerConnection(config);

      // Ajouter le flux local à la connexion
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      peerConnections[peerConnection] = { local: true };

      // Quand un flux distant est reçu, on l'affiche dans une vidéo
      peerConnection.ontrack = (event) => {
        const remoteVideo = document.createElement('video');
        remoteVideo.srcObject = event.streams[0];
        remoteVideo.autoplay = true;
        videosContainer.appendChild(remoteVideo);
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.send(JSON.stringify({ type: 'ice-candidate', candidate: event.candidate }));
        }
      };

      // Créer une offre pour partager la vidéo
      peerConnection.createOffer()
        .then(offer => peerConnection.setLocalDescription(offer))
        .then(() => {
          socket.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
        });
    }

    // Gérer l'offre WebRTC d'un autre utilisateur
    function handleOffer(data) {
      const peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      peerConnections[peerConnection] = { remote: true };

      peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer))
        .then(() => {
          return peerConnection.createAnswer();
        })
        .then(answer => {
          return peerConnection.setLocalDescription(answer);
        })
        .then(() => {
          socket.send(JSON.stringify({ type: 'answer', answer: peerConnection.localDescription }));
        });

      peerConnection.ontrack = (event) => {
        const remoteVideo = document.createElement('video');
        remoteVideo.srcObject = event.streams[0];
        remoteVideo.autoplay = true;
        videosContainer.appendChild(remoteVideo);
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.send(JSON.stringify({ type: 'ice-candidate', candidate: event.candidate }));
        }
      };
    }

    // Gérer la réponse d'un autre utilisateur
    function handleAnswer(data) {
      const peerConnection = Object.keys(peerConnections).find(pc => !peerConnections[pc].remote);
      if (peerConnection) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
      }
    }

    // Gérer les ICE candidates
    function handleIceCandidate(data) {
      const peerConnection = Object.keys(peerConnections).find(pc => peerConnections[pc].local);
      if (peerConnection) {
        peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    }

    // Démarrer la caméra quand le bouton est cliqué
    startButton.addEventListener('click', startCamera);

  </script>

</body>
</html>
